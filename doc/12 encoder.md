# Encoder类实现要求文档

## 1. 概述

Encoder类用于封装ESP32分拣系统中的编码器模块功能，提供精确的位置跟踪、位置回调事件机制和中断处理能力。系统为单向工作，反向旋转将被视为报警状态。

> **重要说明**：相位范围是0-199，代表物理上一圈的位置。编码器内部会跟踪计数值（0-399），但对外接口主要提供相位信息（通过count % 200计算得到）。关于编码器与传送带托架、出口的对应关系，请参考[传送带系统文档](convenyor.md)。

## 2. 编码器技术规格

- **类型**：100线增量式编码器
- **分辨率**：400计数值/转（AB两相，每相100脉冲，双向捕捉）
- **信号**：A相、B相（相差90度的方波）、Z相（每转一个脉冲）
- **工作原理**：
  - 系统单向工作，仅检测正常工作方向
  - 反向旋转将触发报警状态
  - Z相用于确定零位位置
  - 逻辑位置范围：0-199（一圈内的位置，通过count % 200计算得到）
  - 编码器提供位置信息，用于系统同步和触发特定动作
  - 关于编码器与传送带和出口的具体对应关系，请参考[传送带系统文档](convenyor.md)
  - 数据处理和分支器动作在特定计数值位置执行，系统通过托架构象来管理不同位置

## 3. 类定义与成员

### 3.1 公共接口

- **初始化方法**
  - `void initialize()`：初始化编码器引脚和中断设置

- **事件回调方法**
  - `void registerTickCallback(void (*callback)())`：注册每相位变化时的回调函数（用于激光扫描仪、直径扫描仪等采样）
  - `void unregisterTickCallback()`：注销相位变化回调函数
  - `void registerPositionCallback(int position, void (*callback)())`：注册特定位置的回调函数
  - `void unregisterPositionCallback(int position)`：注销特定位置的回调函数
  - `void unregisterAllCallbacks()`：注销所有回调函数

- **状态检测方法**
  - `bool isReverseRotation()`：检查是否发生反向旋转（报警状态）
  - `unsigned long getLastInterruptTime()`：获取最后中断时间戳

- **调试信息方法**
  - `void printStatus()`：输出编码器当前状态信息
  - `void enableDebug(bool enable)`：启用或禁用调试模式

### 3.2 静态成员

- **常量定义**
  - `static const int MAX_CALLBACKS`：最大回调函数数量（如10）

- **中断处理函数**
  - `static void handleAPhaseInterrupt()`：A相中断处理函数
  - `static void handleZPhaseInterrupt()`：Z相中断处理函数

- **实例引用**
  - `static Encoder* instance`：指向Encoder类实例的静态指针，用于中断处理函数访问

### 3.3 私有成员变量

- **计数值和状态**
  - `long count`：编码器计数值
  - `unsigned long lastInterruptTime`：最后中断时间戳
  - `bool debugEnabled`：调试模式标志
  - `bool reverseRotationDetected`：反向旋转检测标志（报警状态）

- **私有方法**
  - `long getCount()`：获取当前编码器计数值（内部使用，不对外开放）
  - `int getPhase()`：获取当前逻辑位置（内部使用，不对外开放）
  - `bool isAtZeroPosition()`：检查是否处于零位位置（内部使用，不对外开放）
  - `void reset()`：重置编码器计数值为零（内部使用，不对外开放）

- **零位检测**
  - `bool zeroPositionDetected`：零位检测标志

- **计数值变化回调**
  - `void (*tickCallback)()`：每计数值变化时的回调函数指针

  - **逻辑位置回调事件**
  - `struct PositionCallback { int position; void (*callback)(); };`：位置回调结构体，position表示逻辑位置
  - `PositionCallback* callbacks[MAX_CALLBACKS]`：位置回调函数数组
  - `int callbackCount`：已注册回调函数数量

## 4. 中断模式实现

- **A相中断**：配置为下降沿触发，检测正常工作方向的旋转
  - 检测到正常方向旋转：更新内部计数值，计算逻辑位置（count % 200），并检查是否达到注册的位置回调点
  - 检测到反向旋转：设置reverseRotationDetected标志，触发报警状态
- **Z相中断**：配置为下降沿触发，用于标记零位位置
  - 触发时，设置zeroPositionDetected标志，用于系统同步
  - 计数值范围：0-399（物理上转一圈可以得到400个计数值）

## 5. 初始化流程

- 配置编码器A相、B相、Z相引脚为输入模式
- 设置上拉电阻
- 配置外部中断处理函数
- 初始化内部状态变量和回调数组
- 重置计数值和报警状态

## 6. 回调事件机制

### 6.1 计数值变化回调（Tick Callback）
- **功能描述**：每一次编码器计数值变化时自动触发的回调机制
- **实现方式**：
  - 维护一个计数值变化回调函数指针
  - 每次编码器计数值更新时，立即执行注册的计数值变化回调函数
- **应用场景**：
  - 调用激光扫描仪进行采样
  - 调用直径扫描仪进行采样
  - 需要实时响应每个相位变化的场景

### 6.2 扫描仪处理回调（Scanner Processing Callback）
- **功能描述**：在特定相位位置处理扫描仪采集的数据，获取物体直径
- **实现方式**：
  - 在编码器到达第85相位时触发
  - 执行数据处理算法，计算物体的精确直径值
  - 将处理后的数据添加到对应位置的托架构象中
- **应用示例**：
  - 分析激光扫描仪采集的信号强度数据
  - 应用算法计算物体的实际直径尺寸
  - 将直径数据存储到索引0的托架构象中

### 6.3 出口判定回调（Exit Decision Callback）
- **功能描述**：判定特定托架构象位置的物体是否应该在当前出口进行分离
- **实现方式**：
  - 维护一个出口判定回调机制，在第85相位时触发
  - 检查当前托架构象索引与出口位置索引是否匹配
  - 根据直径数据和匹配结果决定是否激活分支器
- **应用流程**：
  1. 当编码器到达第85相位时触发此回调
  2. 获取当前位置的托架构象数据
  3. 检查托架构象索引与出口位置索引是否匹配
  4. 如果匹配且有有效直径数据，计算应分配的出口
  5. 如果分配出口与当前出口一致，激活对应的分支器
- **注意事项**：
  - 所有出口（5个出口）的分支器都在同一个相位位置（第85相位）触发动作
  - 每个出口对应传送带上不同的托架构象位置，但触发分支器的相位点是相同的

## 7. 与分支器的协作

- Encoder类为分支器系统提供精确的相位位置信息
- 通过位置回调事件机制，在到达特定相位位置时自动触发分支器动作
- **重要说明**：所有出口（5个出口）的分支器都在同一个相位位置（第85相位）触发动作
- 每个出口对应传送带上不同的托架构象位置，但触发分支器的相位点是相同的
- 例如：在85相位位置时，通过注册的回调函数处理直径扫描数据，并根据检测到的物体直径在对应托架构象位置控制相应出口的分支器动作，然后在后续特定相位位置通过回调函数将分支器复位